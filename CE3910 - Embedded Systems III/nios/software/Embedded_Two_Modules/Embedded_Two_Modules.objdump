
Embedded_Two_Modules.elf:     file format elf32-littlenios2
Embedded_Two_Modules.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000170

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00000020 paddr 0x00000020 align 2**12
         filesz 0x00001080 memsz 0x00001080 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00000000  00000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000150  00000020  00000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00000f08  00000170  00000170  00001170  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000028  00001078  00001078  00002078  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .comment      00000026  00000000  00000000  000020a0  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000001c8  00000000  00000000  000020c8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000002da  00000000  00000000  00002290  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001981  00000000  00000000  0000256a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000642  00000000  00000000  00003eeb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000018a3  00000000  00000000  0000452d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000430  00000000  00000000  00005dd0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000001e9  00000000  00000000  00006200  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000686  00000000  00000000  000063e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_alt_sim_info 00000030  00000000  00000000  00006a70  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000020  00000000  00000000  00006aa0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .thread_model 00000003  00000000  00000000  00007c6b  2**0
                  CONTENTS, READONLY
 16 .cpu          00000003  00000000  00000000  00007c6e  2**0
                  CONTENTS, READONLY
 17 .qsys         00000001  00000000  00000000  00007c71  2**0
                  CONTENTS, READONLY
 18 .simulation_enabled 00000001  00000000  00000000  00007c72  2**0
                  CONTENTS, READONLY
 19 .sysid_hash   00000004  00000000  00000000  00007c73  2**0
                  CONTENTS, READONLY
 20 .sysid_base   00000004  00000000  00000000  00007c77  2**0
                  CONTENTS, READONLY
 21 .sysid_time   00000004  00000000  00000000  00007c7b  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   0000000b  00000000  00000000  00007c7f  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    0000000b  00000000  00000000  00007c8a  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   0000000b  00000000  00000000  00007c95  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 00000011  00000000  00000000  00007ca0  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 00000040  00000000  00000000  00007cb1  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     00093cf1  00000000  00000000  00007cf1  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    d  .entry	00000000 .entry
00000020 l    d  .exceptions	00000000 .exceptions
00000170 l    d  .text	00000000 .text
00001078 l    d  .rodata	00000000 .rodata
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
000001b8 l       .text	00000000 alt_after_alt_main
00000d18 l       .text	00000000 irq_isr_table
00000009 l       *ABS*	00000000 IRQ_ISR_TABLE_ENTRIES
00000034 l       .exceptions	00000000 skip_ea_dec
000000ac l       .exceptions	00000000 check_irqs
000000a8 l       .exceptions	00000000 not_ei
000000e4 l       .exceptions	00000000 end_isr
000000bc l       .exceptions	00000000 check_level_loop
000000d4 l       .exceptions	00000000 irq_level_not_pending
00000000 l    df *ABS*	00000000 LCD.c
000004c8 l     F .text	0000008c lcd_util_pollBusyFlag
00000000 l    df *ABS*	00000000 LED.c
00000000 l    df *ABS*	00000000 PUSHBUTTON.c
00000000 l    df *ABS*	00000000 PWM.c
00000000 l    df *ABS*	00000000 TIMER.c
00000000 l       *ABS*	00000000 irq0
00000002 l       *ABS*	00000000 irq2
00000000 l    df *ABS*	00000000 UART.c
00000000 l    df *ABS*	00000000 main.c
00000000 l       *ABS*	00000000 PIE
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000d3c l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 alt_load.c
00000f08 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000d20 g       .text	00000000 IRQ_2
00000b48 g     F .text	000001d0 alt_main
000010a0 g       *ABS*	00000000 __flash_rwdata_start
0000015c g       .exceptions	00000000 default_isr
000006ec g     F .text	00000098 timer_delay
000005b0 g     F .text	0000003c pushbutton_read
00000308 g     F .text	0000002c lcd_clr
000003e4 g     F .text	000000e4 lcd_printString
00000000 g     F .entry	0000001c __reset
00000020 g       *ABS*	00000000 __flash_exceptions_start
00000d18 g       .text	00000000 IRQ_0
000090a0 g       *ABS*	00000000 _gp
00000784 g     F .text	00000124 timer_interrupt_init
00800000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
00000e78 g     F .text	00000008 __udivsi3
00000d24 g       .text	00000000 IRQ_3
00000fe8 g     F .text	00000090 alt_icache_flush
000005ec g     F .text	00000080 PWMwriteOCRA
000010a0 g       *ABS*	00000000 __bss_end
00000a84 g     F .text	0000004c uart_putch
00000f74 g     F .text	00000044 alt_dcache_flush_all
00000334 g     F .text	00000034 lcd_home
000010a0 g       *ABS*	00000000 __ram_rwdata_end
00000900 g     F .text	0000002c timer_ISR_TIMER_0
000008a8 g     F .text	00000058 timer_interrupt_start_stop
000010a0 g       *ABS*	00000000 __ram_rodata_end
00000e80 g     F .text	00000008 __umodsi3
000010a0 g       *ABS*	00000000 end
00800000 g       *ABS*	00000000 __alt_stack_pointer
00000958 g     F .text	0000012c uart_init
00000170 g     F .text	0000004c _start
00000d28 g       .text	00000000 IRQ_4
00000584 g     F .text	0000002c LED_read
000010a0 g       *ABS*	00000000 __ram_rwdata_start
00001078 g       *ABS*	00000000 __ram_rodata_start
000003b4 g     F .text	00000030 lcd_portInit
000010a0 g       *ABS*	00000000 __alt_stack_base
000010a0 g       *ABS*	00000000 __bss_start
00000368 g     F .text	0000004c lcd_init
00000000         *UND*	00000000 main
00000db8 g     F .text	00000060 __divsi3
00000b18 g     F .text	00000030 testTimerInterrupt
00001078 g       *ABS*	00000000 __flash_rodata_start
00000260 g     F .text	000000a8 lcd_prt
00000d30 g       .text	00000000 IRQ_6
00000d38 g       .text	00000000 IRQ_8
00000020 g       *ABS*	00000000 __ram_exceptions_start
000010a0 g       *ABS*	00000000 _edata
000010a0 g       *ABS*	00000000 _end
00000ad0 g     F .text	00000048 uart_getch
00000d2c g       .text	00000000 IRQ_5
00000170 g       *ABS*	00000000 __ram_exceptions_end
0000092c g     F .text	0000002c timer_ISR_TIMER_1
00000e18 g     F .text	00000060 __modsi3
00800000 g       *ABS*	00000000 __alt_data_end
00000000 g       *ABS*	00000000 __alt_mem_sdram
000001bc g     F .text	000000a4 lcd_cmd
00000d1c g       .text	00000000 IRQ_1
00000d34 g       .text	00000000 IRQ_7
00000fb8 g     F .text	00000030 alt_icache_flush_all
0000066c g     F .text	00000080 PWMwriteOCRB
00000e88 g     F .text	00000080 alt_load
00000554 g     F .text	00000030 LED_write
00000020 g       .exceptions	00000000 exception_handler



Disassembly of section .entry:

00000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   0:	00840014 	movui	r2,4096
#endif

0:
    initi r2
   4:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   8:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   c:	00bffd16 	blt	zero,r2,4 <irq2+0x2>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  10:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
  14:	08405c14 	ori	at,at,368
    jmp r1
  18:	0800683a 	jmp	at
  1c:	00000000 	call	0 <__reset>

Disassembly of section .exceptions:

00000020 <exception_handler>:
 * Exception handler for the NIOS processor.
*/
.global exception_handler
exception_handler:
	//Save to stack
	subi sp, sp, 28 * 4
  20:	deffe404 	addi	sp,sp,-112
	stw et, 0 * 4(sp)
  24:	de000015 	stw	et,0(sp)
	rdctl et, ipending
  28:	0031313a 	rdctl	et,ipending
	// Check if interrupt is external
	beq et, r0, skip_ea_dec
  2c:	c0000126 	beq	et,zero,34 <skip_ea_dec>
	// Decrement ea by one instruction for external interrupts
	// so the interrupted instruction wil be started again
	// adter eret
	subi ea, ea, 4
  30:	ef7fff04 	addi	ea,ea,-4

00000034 <skip_ea_dec>:
skip_ea_dec:
	// Save all registers than are normally caller saved
	stw ea, 4*1(sp)
  34:	df400115 	stw	ea,4(sp)
	stw r1, 4*2(sp)
  38:	d8400215 	stw	at,8(sp)
	stw r2, 4*3(sp)
  3c:	d8800315 	stw	r2,12(sp)
	stw r3, 4*4(sp)
  40:	d8c00415 	stw	r3,16(sp)
	stw r4, 4*5(sp)
  44:	d9000515 	stw	r4,20(sp)
	stw r5, 4*6(sp)
  48:	d9400615 	stw	r5,24(sp)
	stw r5, 4*7(sp)
  4c:	d9400715 	stw	r5,28(sp)
	stw r6, 4*8(sp)
  50:	d9800815 	stw	r6,32(sp)
	stw r7, 4*9(sp)
  54:	d9c00915 	stw	r7,36(sp)
	stw r8, 4*10(sp)
  58:	da000a15 	stw	r8,40(sp)
	stw r9, 4*11(sp)
  5c:	da400b15 	stw	r9,44(sp)
	stw r10, 4*12(sp)
  60:	da800c15 	stw	r10,48(sp)
	stw r11, 4*13(sp)
  64:	dac00d15 	stw	r11,52(sp)
	stw r12, 4*14(sp)
  68:	db000e15 	stw	r12,56(sp)
	stw r13, 4*15(sp)
  6c:	db400f15 	stw	r13,60(sp)
	stw r14, 4*16(sp)
  70:	db801015 	stw	r14,64(sp)
	stw r15, 4*17(sp)
  74:	dbc01115 	stw	r15,68(sp)
	stw r16, 4*18(sp)
  78:	dc001215 	stw	r16,72(sp)
	stw r17, 4*19(sp)
  7c:	dc401315 	stw	r17,76(sp)
	stw r18, 4*20(sp)
  80:	dc801415 	stw	r18,80(sp)
	stw r19, 4*21(sp)
  84:	dcc01515 	stw	r19,84(sp)
	stw r20, 4*22(sp)
  88:	dd001615 	stw	r20,88(sp)
	stw r21, 4*23(sp)
  8c:	dd401715 	stw	r21,92(sp)
	stw r22, 4*24(sp)
  90:	dd801815 	stw	r22,96(sp)
	stw r23, 4*25(sp)
  94:	ddc01915 	stw	r23,100(sp)
	stw r28, 4*26(sp) // fp
  98:	df001a15 	stw	fp,104(sp)
	stw r31, 4*27(sp) // ra
  9c:	dfc01b15 	stw	ra,108(sp)

	rdctl et, ipending
  a0:	0031313a 	rdctl	et,ipending
	// Check if interrupt is external
	bne et, zero, check_irqs
  a4:	c000011e 	bne	et,zero,ac <check_irqs>

000000a8 <not_ei>:
not_ei:
	// Exception must be unimplemented instruction or
	// trap instruction, do not handle
	br end_isr
  a8:	00000e06 	br	e4 <end_isr>

000000ac <check_irqs>:

check_irqs:
	// Check levels and dispatch to ISR for the IRQ
	movui r9, 1
  ac:	02400054 	movui	r9,1
	movui r10, IRQ_ISR_TABLE_ENTRIES
  b0:	02800254 	movui	r10,9
  b4:	02c00034 	movhi	r11,0
	movia r11, irq_isr_table
  b8:	5ac34604 	addi	r11,r11,3352

000000bc <check_level_loop>:
check_level_loop:
	beq r10, zero, end_isr
  bc:	50000926 	beq	r10,zero,e4 <end_isr>
	// Check for interrupt level N
	and r8, et, r9
  c0:	c250703a 	and	r8,et,r9
	beq r8, zero, irq_level_not_pending
  c4:	40000326 	beq	r8,zero,d4 <irq_level_not_pending>
	ldw r12, 0(r11)
  c8:	5b000017 	ldw	r12,0(r11)
	callr r12
  cc:	603ee83a 	callr	r12
	br end_isr
  d0:	00000406 	br	e4 <end_isr>

000000d4 <irq_level_not_pending>:
irq_level_not_pending:
	addi r11, r11, 4
  d4:	5ac00104 	addi	r11,r11,4
	slli r9, r9, 1
  d8:	4812907a 	slli	r9,r9,1
	subi r10, r10, 1
  dc:	52bfffc4 	addi	r10,r10,-1
	br check_level_loop
  e0:	003ff606 	br	bc <check_level_loop>

000000e4 <end_isr>:

end_isr:
	// Restore from stack
	ldw et, 0*4(sp)
  e4:	de000017 	ldw	et,0(sp)
	ldw ea, 1*4(sp)
  e8:	df400117 	ldw	ea,4(sp)
	ldw r1, 4*2(sp)
  ec:	d8400217 	ldw	at,8(sp)
	ldw r2, 4*3(sp)
  f0:	d8800317 	ldw	r2,12(sp)
	ldw r3, 4*4(sp)
  f4:	d8c00417 	ldw	r3,16(sp)
	ldw r4, 4*5(sp)
  f8:	d9000517 	ldw	r4,20(sp)
	ldw r5, 4*6(sp)
  fc:	d9400617 	ldw	r5,24(sp)
	ldw r5, 4*7(sp)
 100:	d9400717 	ldw	r5,28(sp)
	ldw r6, 4*8(sp)
 104:	d9800817 	ldw	r6,32(sp)
	ldw r7, 4*9(sp)
 108:	d9c00917 	ldw	r7,36(sp)
	ldw r8, 4*10(sp)
 10c:	da000a17 	ldw	r8,40(sp)
	ldw r9, 4*11(sp)
 110:	da400b17 	ldw	r9,44(sp)
	ldw r10, 4*12(sp)
 114:	da800c17 	ldw	r10,48(sp)
	ldw r11, 4*13(sp)
 118:	dac00d17 	ldw	r11,52(sp)
	ldw r12, 4*14(sp)
 11c:	db000e17 	ldw	r12,56(sp)
	ldw r13, 4*15(sp)
 120:	db400f17 	ldw	r13,60(sp)
	ldw r14, 4*16(sp)
 124:	db801017 	ldw	r14,64(sp)
	ldw r15, 4*17(sp)
 128:	dbc01117 	ldw	r15,68(sp)
	ldw r16, 4*18(sp)
 12c:	dc001217 	ldw	r16,72(sp)
	ldw r17, 4*19(sp)
 130:	dc401317 	ldw	r17,76(sp)
	ldw r18, 4*20(sp)
 134:	dc801417 	ldw	r18,80(sp)
	ldw r19, 4*21(sp)
 138:	dcc01517 	ldw	r19,84(sp)
	ldw r20, 4*22(sp)
 13c:	dd001617 	ldw	r20,88(sp)
	ldw r21, 4*23(sp)
 140:	dd401717 	ldw	r21,92(sp)
	ldw r22, 4*24(sp)
 144:	dd801817 	ldw	r22,96(sp)
	ldw r23, 4*25(sp)
 148:	ddc01917 	ldw	r23,100(sp)
	ldw r28, 4*26(sp) // fp
 14c:	df001a17 	ldw	fp,104(sp)
	ldw r31, 4*27(sp) // ra
 150:	dfc01b17 	ldw	ra,108(sp)
	addi sp, sp, 28 * 4
 154:	dec01c04 	addi	sp,sp,112
	eret
 158:	ef80083a 	eret

0000015c <default_isr>:
 * Default noop interrupt service routine
*/
.global default_isr
default_isr:
	// Save to stack
	subi sp, sp, 1*4
 15c:	deffff04 	addi	sp,sp,-4
	stw ra, 0*4(sp)
 160:	dfc00015 	stw	ra,0(sp)

	// Restore from stack
	ldw ra, 0, 0*4(sp)
 164:	dfc00017 	ldw	ra,0(sp)
	addi sp, sp, 1 * 4
 168:	dec00104 	addi	sp,sp,4
	ret
 16c:	f800283a 	ret

Disassembly of section .text:

00000170 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
     170:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
     174:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
     178:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
     17c:	00bffd16 	blt	zero,r2,174 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
     180:	06c02034 	movhi	sp,128
    ori sp, sp, %lo(__alt_stack_pointer)
     184:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
     188:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
     18c:	d6a42814 	ori	gp,gp,37024
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
     190:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
     194:	10842814 	ori	r2,r2,4256

    movhi r3, %hi(__bss_end)
     198:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
     19c:	18c42814 	ori	r3,r3,4256

    beq r2, r3, 1f
     1a0:	10c00326 	beq	r2,r3,1b0 <_start+0x40>

0:
    stw zero, (r2)
     1a4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
     1a8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
     1ac:	10fffd36 	bltu	r2,r3,1a4 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
     1b0:	0000e880 	call	e88 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
     1b4:	0000b480 	call	b48 <alt_main>

000001b8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
     1b8:	003fff06 	br	1b8 <alt_after_alt_main>

000001bc <lcd_cmd>:

/**
 * Writes a command to the LCD.
 * @param cmd command to be sent to LCD.
 */
void lcd_cmd(uint8_t cmd){
     1bc:	defffc04 	addi	sp,sp,-16
     1c0:	dfc00315 	stw	ra,12(sp)
     1c4:	df000215 	stw	fp,8(sp)
     1c8:	df000204 	addi	fp,sp,8
     1cc:	e13fff05 	stb	r4,-4(fp)
	//temporary value for data pin manipulation
	uint8_t ctrlVal;

	//Wait till LCD is ready to accept new instruction
	lcd_util_pollBusyFlag();
     1d0:	00004c80 	call	4c8 <lcd_util_pollBusyFlag>

	// write E=RS=RW=0
	(LCD_CTRL->L_CTRL) = LCD_DATA_CMD_SELECT_CMD_MASK;
     1d4:	00a02034 	movhi	r2,32896
     1d8:	10882004 	addi	r2,r2,8320
     1dc:	10000005 	stb	zero,0(r2)

	// write command to data port
	(LCD_DATA->DATA) = cmd;
     1e0:	00e02034 	movhi	r3,32896
     1e4:	18c82804 	addi	r3,r3,8352
     1e8:	e0bfff03 	ldbu	r2,-4(fp)
     1ec:	18800015 	stw	r2,0(r3)

	// set enable ON
	ctrlVal = (LCD_CTRL->L_CTRL) | LCD_ENABLE_ON_MASK;
     1f0:	00a02034 	movhi	r2,32896
     1f4:	10882004 	addi	r2,r2,8320
     1f8:	10800003 	ldbu	r2,0(r2)
     1fc:	10800114 	ori	r2,r2,4
     200:	e0bffe05 	stb	r2,-8(fp)
	(LCD_CTRL->L_CTRL) = ctrlVal;
     204:	00e02034 	movhi	r3,32896
     208:	18c82004 	addi	r3,r3,8320
     20c:	e0bffe03 	ldbu	r2,-8(fp)
     210:	18800005 	stb	r2,0(r3)

	// delay for 500ns
	timer_delay(500, TIMER_1);
     214:	01007d04 	movi	r4,500
     218:	01602034 	movhi	r5,32896
     21c:	29481804 	addi	r5,r5,8288
     220:	00006ec0 	call	6ec <timer_delay>

	// set enable OFF
	ctrlVal = (LCD_CTRL->L_CTRL) & LCD_ENABLE_OFF_MASK;
     224:	00a02034 	movhi	r2,32896
     228:	10882004 	addi	r2,r2,8320
     22c:	10c00003 	ldbu	r3,0(r2)
     230:	00bffec4 	movi	r2,-5
     234:	1884703a 	and	r2,r3,r2
     238:	e0bffe05 	stb	r2,-8(fp)
	(LCD_CTRL->L_CTRL) = ctrlVal;
     23c:	00e02034 	movhi	r3,32896
     240:	18c82004 	addi	r3,r3,8320
     244:	e0bffe03 	ldbu	r2,-8(fp)
     248:	18800005 	stb	r2,0(r3)

}
     24c:	e037883a 	mov	sp,fp
     250:	dfc00117 	ldw	ra,4(sp)
     254:	df000017 	ldw	fp,0(sp)
     258:	dec00204 	addi	sp,sp,8
     25c:	f800283a 	ret

00000260 <lcd_prt>:

/**
 * Writes a character to the LCD.
 * @param c character that is to be sent to LCD.
 */
void lcd_prt(char c){
     260:	defffc04 	addi	sp,sp,-16
     264:	dfc00315 	stw	ra,12(sp)
     268:	df000215 	stw	fp,8(sp)
     26c:	df000204 	addi	fp,sp,8
     270:	e13fff05 	stb	r4,-4(fp)

	//temporary value for data pin manipulation
	uint8_t ctrlVal;

	//Wait till LCD is ready to accept new instruction
	lcd_util_pollBusyFlag();
     274:	00004c80 	call	4c8 <lcd_util_pollBusyFlag>

	// write RW=E=0 RS=1  "0b010"
	(LCD_CTRL->L_CTRL) = LCD_DATA_CMD_SELECT_DATA_MASK;
     278:	00e02034 	movhi	r3,32896
     27c:	18c82004 	addi	r3,r3,8320
     280:	00800084 	movi	r2,2
     284:	18800005 	stb	r2,0(r3)

	// write character to data port
	(LCD_DATA->DATA) = c;
     288:	00e02034 	movhi	r3,32896
     28c:	18c82804 	addi	r3,r3,8352
     290:	e0bfff07 	ldb	r2,-4(fp)
     294:	18800015 	stw	r2,0(r3)

	// set enable ON
	ctrlVal = (LCD_CTRL->L_CTRL) | LCD_ENABLE_ON_MASK;
     298:	00a02034 	movhi	r2,32896
     29c:	10882004 	addi	r2,r2,8320
     2a0:	10800003 	ldbu	r2,0(r2)
     2a4:	10800114 	ori	r2,r2,4
     2a8:	e0bffe05 	stb	r2,-8(fp)
	(LCD_CTRL->L_CTRL) = ctrlVal;
     2ac:	00e02034 	movhi	r3,32896
     2b0:	18c82004 	addi	r3,r3,8320
     2b4:	e0bffe03 	ldbu	r2,-8(fp)
     2b8:	18800005 	stb	r2,0(r3)

	// delay for 500ns
	timer_delay(500, TIMER_1);
     2bc:	01007d04 	movi	r4,500
     2c0:	01602034 	movhi	r5,32896
     2c4:	29481804 	addi	r5,r5,8288
     2c8:	00006ec0 	call	6ec <timer_delay>

	// set enable OFF
	ctrlVal = (LCD_CTRL->L_CTRL) & LCD_ENABLE_OFF_MASK;
     2cc:	00a02034 	movhi	r2,32896
     2d0:	10882004 	addi	r2,r2,8320
     2d4:	10c00003 	ldbu	r3,0(r2)
     2d8:	00bffec4 	movi	r2,-5
     2dc:	1884703a 	and	r2,r3,r2
     2e0:	e0bffe05 	stb	r2,-8(fp)
	(LCD_CTRL->L_CTRL) = ctrlVal;
     2e4:	00e02034 	movhi	r3,32896
     2e8:	18c82004 	addi	r3,r3,8320
     2ec:	e0bffe03 	ldbu	r2,-8(fp)
     2f0:	18800005 	stb	r2,0(r3)
}
     2f4:	e037883a 	mov	sp,fp
     2f8:	dfc00117 	ldw	ra,4(sp)
     2fc:	df000017 	ldw	fp,0(sp)
     300:	dec00204 	addi	sp,sp,8
     304:	f800283a 	ret

00000308 <lcd_clr>:

/**
 * Writes the clear command to the LCD.
 */
void lcd_clr(void){
     308:	defffe04 	addi	sp,sp,-8
     30c:	dfc00115 	stw	ra,4(sp)
     310:	df000015 	stw	fp,0(sp)
     314:	d839883a 	mov	fp,sp
	lcd_cmd(LCD_CMD_CLEAR);
     318:	01000044 	movi	r4,1
     31c:	00001bc0 	call	1bc <lcd_cmd>
}
     320:	e037883a 	mov	sp,fp
     324:	dfc00117 	ldw	ra,4(sp)
     328:	df000017 	ldw	fp,0(sp)
     32c:	dec00204 	addi	sp,sp,8
     330:	f800283a 	ret

00000334 <lcd_home>:

/**
 * Moves the cursor back to home on the LCD.
 */
void lcd_home(void){
     334:	defffe04 	addi	sp,sp,-8
     338:	dfc00115 	stw	ra,4(sp)
     33c:	df000015 	stw	fp,0(sp)
     340:	d839883a 	mov	fp,sp
	lcd_cmd(LCD_CMD_INCREMENT_CURSOR_1);
     344:	01000184 	movi	r4,6
     348:	00001bc0 	call	1bc <lcd_cmd>
	lcd_cmd(LCD_CMD_CURSOR_HOME);
     34c:	01000084 	movi	r4,2
     350:	00001bc0 	call	1bc <lcd_cmd>
}
     354:	e037883a 	mov	sp,fp
     358:	dfc00117 	ldw	ra,4(sp)
     35c:	df000017 	ldw	fp,0(sp)
     360:	dec00204 	addi	sp,sp,8
     364:	f800283a 	ret

00000368 <lcd_init>:

/**
 * Initializes the LCD. Sends out the command stream to setup the display. Must
 * call LCDportInit first for direction setting.
 */
void lcd_init(void){
     368:	defffe04 	addi	sp,sp,-8
     36c:	dfc00115 	stw	ra,4(sp)
     370:	df000015 	stw	fp,0(sp)
     374:	d839883a 	mov	fp,sp
	lcd_cmd(LCD_CMD_DATALENGTH_8BIT);
     378:	01000e04 	movi	r4,56
     37c:	00001bc0 	call	1bc <lcd_cmd>
	lcd_cmd(LCD_CMD_DISPLAY_CURSOR_BLINK_ON);
     380:	010003c4 	movi	r4,15
     384:	00001bc0 	call	1bc <lcd_cmd>
	lcd_cmd(LCD_CMD_CLEAR);
     388:	01000044 	movi	r4,1
     38c:	00001bc0 	call	1bc <lcd_cmd>
	lcd_cmd(LCD_CMD_INCREMENT_CURSOR_1);
     390:	01000184 	movi	r4,6
     394:	00001bc0 	call	1bc <lcd_cmd>
	lcd_cmd(LCD_CMD_CURSOR_HOME);
     398:	01000084 	movi	r4,2
     39c:	00001bc0 	call	1bc <lcd_cmd>
}
     3a0:	e037883a 	mov	sp,fp
     3a4:	dfc00117 	ldw	ra,4(sp)
     3a8:	df000017 	ldw	fp,0(sp)
     3ac:	dec00204 	addi	sp,sp,8
     3b0:	f800283a 	ret

000003b4 <lcd_portInit>:

/**
 * Sets the direction of the LCD data port.
 * @param dir Port direction mask for the LCD data port
 */
void lcd_portInit(uint8_t dir){
     3b4:	defffe04 	addi	sp,sp,-8
     3b8:	df000115 	stw	fp,4(sp)
     3bc:	df000104 	addi	fp,sp,4
     3c0:	e13fff05 	stb	r4,-4(fp)
	(LCD_DATA->DIRECTION) = dir;
     3c4:	00e02034 	movhi	r3,32896
     3c8:	18c82804 	addi	r3,r3,8352
     3cc:	e0bfff03 	ldbu	r2,-4(fp)
     3d0:	18800115 	stw	r2,4(r3)
}
     3d4:	e037883a 	mov	sp,fp
     3d8:	df000017 	ldw	fp,0(sp)
     3dc:	dec00104 	addi	sp,sp,4
     3e0:	f800283a 	ret

000003e4 <lcd_printString>:

/**
 * Prints a string of characters to the LCD.
 * @param ptr pointer to the start of a C-string ended with a nul character.
 */
void lcd_printString(char* ptr){
     3e4:	defffc04 	addi	sp,sp,-16
     3e8:	dfc00315 	stw	ra,12(sp)
     3ec:	df000215 	stw	fp,8(sp)
     3f0:	df000204 	addi	fp,sp,8
     3f4:	e13fff15 	stw	r4,-4(fp)
	int counter;
	for(counter = 0; (*ptr != '\0')&&(counter != 32); counter++){
     3f8:	e03ffe15 	stw	zero,-8(fp)
     3fc:	00002306 	br	48c <lcd_printString+0xa8>

		// If enter character
		if(*ptr == '\n'){
     400:	e0bfff17 	ldw	r2,-4(fp)
     404:	10800003 	ldbu	r2,0(r2)
     408:	10803fcc 	andi	r2,r2,255
     40c:	1080201c 	xori	r2,r2,128
     410:	10bfe004 	addi	r2,r2,-128
     414:	10800298 	cmpnei	r2,r2,10
     418:	10000b1e 	bne	r2,zero,448 <lcd_printString+0x64>
			//If on first line move to second
			if(counter < 16){
     41c:	e0bffe17 	ldw	r2,-8(fp)
     420:	10800408 	cmpgei	r2,r2,16
     424:	1000231e 	bne	r2,zero,4b4 <lcd_printString+0xd0>
				lcd_cmd(LCD_SECONDLINE_CMD);
     428:	01003004 	movi	r4,192
     42c:	00001bc0 	call	1bc <lcd_cmd>
				counter = 16;
     430:	00800404 	movi	r2,16
     434:	e0bffe15 	stw	r2,-8(fp)
			else {
				return;
			}

			//index pointer
			ptr++;
     438:	e0bfff17 	ldw	r2,-4(fp)
     43c:	10800044 	addi	r2,r2,1
     440:	e0bfff15 	stw	r2,-4(fp)
     444:	00000e06 	br	480 <lcd_printString+0x9c>
		}
		//Roll over to second line when first line fills
		else{
			if(counter == 16)
     448:	e0bffe17 	ldw	r2,-8(fp)
     44c:	10800418 	cmpnei	r2,r2,16
     450:	1000021e 	bne	r2,zero,45c <lcd_printString+0x78>
				lcd_cmd(LCD_SECONDLINE_CMD);
     454:	01003004 	movi	r4,192
     458:	00001bc0 	call	1bc <lcd_cmd>

			//print the character and index pointer
			lcd_prt(*ptr);
     45c:	e0bfff17 	ldw	r2,-4(fp)
     460:	10800003 	ldbu	r2,0(r2)
     464:	11003fcc 	andi	r4,r2,255
     468:	2100201c 	xori	r4,r4,128
     46c:	213fe004 	addi	r4,r4,-128
     470:	00002600 	call	260 <lcd_prt>
			ptr++;
     474:	e0bfff17 	ldw	r2,-4(fp)
     478:	10800044 	addi	r2,r2,1
     47c:	e0bfff15 	stw	r2,-4(fp)
 * Prints a string of characters to the LCD.
 * @param ptr pointer to the start of a C-string ended with a nul character.
 */
void lcd_printString(char* ptr){
	int counter;
	for(counter = 0; (*ptr != '\0')&&(counter != 32); counter++){
     480:	e0bffe17 	ldw	r2,-8(fp)
     484:	10800044 	addi	r2,r2,1
     488:	e0bffe15 	stw	r2,-8(fp)
     48c:	e0bfff17 	ldw	r2,-4(fp)
     490:	10800003 	ldbu	r2,0(r2)
     494:	10803fcc 	andi	r2,r2,255
     498:	1080201c 	xori	r2,r2,128
     49c:	10bfe004 	addi	r2,r2,-128
     4a0:	1005003a 	cmpeq	r2,r2,zero
     4a4:	1000031e 	bne	r2,zero,4b4 <lcd_printString+0xd0>
     4a8:	e0bffe17 	ldw	r2,-8(fp)
     4ac:	10800818 	cmpnei	r2,r2,32
     4b0:	103fd31e 	bne	r2,zero,400 <lcd_printString+0x1c>
			//print the character and index pointer
			lcd_prt(*ptr);
			ptr++;
		}
	}
}
     4b4:	e037883a 	mov	sp,fp
     4b8:	dfc00117 	ldw	ra,4(sp)
     4bc:	df000017 	ldw	fp,0(sp)
     4c0:	dec00204 	addi	sp,sp,8
     4c4:	f800283a 	ret

000004c8 <lcd_util_pollBusyFlag>:

/**
 * Polls the busy flag of the LCD to synchronize the program to the LCD
 * instruction execution.
 */
static void lcd_util_pollBusyFlag(){
     4c8:	defffd04 	addi	sp,sp,-12
     4cc:	df000215 	stw	fp,8(sp)
     4d0:	df000204 	addi	fp,sp,8

	//Set data register to input
	uint32_t tempDataDir = (LCD_DATA->DIRECTION);
     4d4:	00a02034 	movhi	r2,32896
     4d8:	10882804 	addi	r2,r2,8352
     4dc:	10800117 	ldw	r2,4(r2)
     4e0:	e0bfff15 	stw	r2,-4(fp)
	(LCD_DATA->DIRECTION) = 0;
     4e4:	00a02034 	movhi	r2,32896
     4e8:	10882804 	addi	r2,r2,8352
     4ec:	10000115 	stw	zero,4(r2)

	// Set RW=E=1, RS=0 to get visible busy flag
	(LCD_CTRL->L_CTRL) = 0x5;
     4f0:	00e02034 	movhi	r3,32896
     4f4:	18c82004 	addi	r3,r3,8320
     4f8:	00800144 	movi	r2,5
     4fc:	18800005 	stb	r2,0(r3)

	// Needs small delay since processor is faster than LCD. Thus this noop
	// is ran.
	int i = 0; i++;
     500:	e03ffe15 	stw	zero,-8(fp)
     504:	e0bffe17 	ldw	r2,-8(fp)
     508:	10800044 	addi	r2,r2,1
     50c:	e0bffe15 	stw	r2,-8(fp)

	// Poll busy flag while it is active, since old operation is still running
	while((LCD_DATA->DATA) & 0x80);
     510:	00a02034 	movhi	r2,32896
     514:	10882804 	addi	r2,r2,8352
     518:	10800017 	ldw	r2,0(r2)
     51c:	1080200c 	andi	r2,r2,128
     520:	1004c03a 	cmpne	r2,r2,zero
     524:	103ffa1e 	bne	r2,zero,510 <lcd_util_pollBusyFlag+0x48>

	// Restore the initial direction of the data ports
	(LCD_DATA->DIRECTION) = tempDataDir;
     528:	00a02034 	movhi	r2,32896
     52c:	10882804 	addi	r2,r2,8352
     530:	e0ffff17 	ldw	r3,-4(fp)
     534:	10c00115 	stw	r3,4(r2)
	(LCD_CTRL->L_CTRL) = 0;
     538:	00a02034 	movhi	r2,32896
     53c:	10882004 	addi	r2,r2,8320
     540:	10000005 	stb	zero,0(r2)
}
     544:	e037883a 	mov	sp,fp
     548:	df000017 	ldw	fp,0(sp)
     54c:	dec00104 	addi	sp,sp,4
     550:	f800283a 	ret

00000554 <LED_write>:

/**
 * Writes the value to the data register
 * @param output sets this value
 */
void LED_write(uint16_t output){
     554:	defffe04 	addi	sp,sp,-8
     558:	df000115 	stw	fp,4(sp)
     55c:	df000104 	addi	fp,sp,4
     560:	e13fff0d 	sth	r4,-4(fp)
	(LEDS -> DATA) = output;
     564:	00e02034 	movhi	r3,32896
     568:	18c80c04 	addi	r3,r3,8240
     56c:	e0bfff0b 	ldhu	r2,-4(fp)
     570:	18800015 	stw	r2,0(r3)
}
     574:	e037883a 	mov	sp,fp
     578:	df000017 	ldw	fp,0(sp)
     57c:	dec00104 	addi	sp,sp,4
     580:	f800283a 	ret

00000584 <LED_read>:

/**
 * Reads from the data register
 * @return value from register which is activity of LEDs
 */
uint16_t LED_read(){
     584:	deffff04 	addi	sp,sp,-4
     588:	df000015 	stw	fp,0(sp)
     58c:	d839883a 	mov	fp,sp
	return (LEDS -> DATA);
     590:	00a02034 	movhi	r2,32896
     594:	10880c04 	addi	r2,r2,8240
     598:	10800017 	ldw	r2,0(r2)
     59c:	10bfffcc 	andi	r2,r2,65535
}
     5a0:	e037883a 	mov	sp,fp
     5a4:	df000017 	ldw	fp,0(sp)
     5a8:	dec00104 	addi	sp,sp,4
     5ac:	f800283a 	ret

000005b0 <pushbutton_read>:
 * Reads the raw data from the pushbutton. Note that the pushbutton logic is
 * inverted.
 * @param selectedButton number for the correct pushbutton. 1 or 2
 * @return  masked value returning value for register
 */
uint8_t pushbutton_read(uint8_t selectedButton){
     5b0:	defffe04 	addi	sp,sp,-8
     5b4:	df000115 	stw	fp,4(sp)
     5b8:	df000104 	addi	fp,sp,4
     5bc:	e13fff05 	stb	r4,-4(fp)
	return (PUSHBUTTON -> DATA) & selectedButton;
     5c0:	00a02034 	movhi	r2,32896
     5c4:	10883404 	addi	r2,r2,8400
     5c8:	10800017 	ldw	r2,0(r2)
     5cc:	1007883a 	mov	r3,r2
     5d0:	e0bfff03 	ldbu	r2,-4(fp)
     5d4:	1884703a 	and	r2,r3,r2
     5d8:	10803fcc 	andi	r2,r2,255
}
     5dc:	e037883a 	mov	sp,fp
     5e0:	df000017 	ldw	fp,0(sp)
     5e4:	dec00104 	addi	sp,sp,4
     5e8:	f800283a 	ret

000005ec <PWMwriteOCRA>:
 * @param dutyPercent Duty cycle, given as a percent from 0 to 100. (anything
 *        lower or higher will be ignored and no change will occur to register
 * @return Either a 0 if there was no error (Bad input) or a EOF (-1) if the
 *         input was out of bounds.
 */
int PWMwriteOCRA(int dutyCycle){
     5ec:	defffc04 	addi	sp,sp,-16
     5f0:	df000315 	stw	fp,12(sp)
     5f4:	df000304 	addi	fp,sp,12
     5f8:	e13ffe15 	stw	r4,-8(fp)
	if((dutyCycle <= 100) && (dutyCycle >= 0)){
     5fc:	e0bffe17 	ldw	r2,-8(fp)
     600:	10801948 	cmpgei	r2,r2,101
     604:	1000121e 	bne	r2,zero,650 <PWMwriteOCRA+0x64>
     608:	e0bffe17 	ldw	r2,-8(fp)
     60c:	1004803a 	cmplt	r2,r2,zero
     610:	10000f1e 	bne	r2,zero,650 <PWMwriteOCRA+0x64>
		//Convert from percent to the acceptable OCR value with max 20000
		int duty = dutyCycle * (MAX_OCR_VALUE / 100);
     614:	e0bffe17 	ldw	r2,-8(fp)
     618:	10803224 	muli	r2,r2,200
     61c:	e0bffd15 	stw	r2,-12(fp)
		//We can never actually get to 20000 based on my CE2800 notes
		if(duty == MAX_OCR_VALUE)
     620:	e0bffd17 	ldw	r2,-12(fp)
     624:	10938818 	cmpnei	r2,r2,20000
     628:	1000031e 	bne	r2,zero,638 <PWMwriteOCRA+0x4c>
			duty--;
     62c:	e0bffd17 	ldw	r2,-12(fp)
     630:	10bfffc4 	addi	r2,r2,-1
     634:	e0bffd15 	stw	r2,-12(fp)
		//set register
		*OCRA = duty;
     638:	00a02034 	movhi	r2,32896
     63c:	10880a04 	addi	r2,r2,8232
     640:	e0fffd17 	ldw	r3,-12(fp)
     644:	10c0000d 	sth	r3,0(r2)
	} else {
		return -1; // return an error
	}
	// no error
	return 0;
     648:	e03fff15 	stw	zero,-4(fp)
     64c:	00000206 	br	658 <PWMwriteOCRA+0x6c>
		if(duty == MAX_OCR_VALUE)
			duty--;
		//set register
		*OCRA = duty;
	} else {
		return -1; // return an error
     650:	00bfffc4 	movi	r2,-1
     654:	e0bfff15 	stw	r2,-4(fp)
     658:	e0bfff17 	ldw	r2,-4(fp)
	}
	// no error
	return 0;
}
     65c:	e037883a 	mov	sp,fp
     660:	df000017 	ldw	fp,0(sp)
     664:	dec00104 	addi	sp,sp,4
     668:	f800283a 	ret

0000066c <PWMwriteOCRB>:
 * @param dutyPercent Duty cycle, given as a percent from 0 to 100. (anything
 *        lower or higher will be ignored and no change will occur to register
 * @return Either a 0 if there was no error (Bad input) or a EOF (-1) if the
 *         input was out of bounds.
 */
int PWMwriteOCRB(int dutyCycle){
     66c:	defffc04 	addi	sp,sp,-16
     670:	df000315 	stw	fp,12(sp)
     674:	df000304 	addi	fp,sp,12
     678:	e13ffe15 	stw	r4,-8(fp)
	if((dutyCycle <= 100) && (dutyCycle >= 0)){
     67c:	e0bffe17 	ldw	r2,-8(fp)
     680:	10801948 	cmpgei	r2,r2,101
     684:	1000121e 	bne	r2,zero,6d0 <PWMwriteOCRB+0x64>
     688:	e0bffe17 	ldw	r2,-8(fp)
     68c:	1004803a 	cmplt	r2,r2,zero
     690:	10000f1e 	bne	r2,zero,6d0 <PWMwriteOCRB+0x64>
		//Convert from percent to the acceptable OCR value with max 20000
		int duty = dutyCycle * (MAX_OCR_VALUE / 100);
     694:	e0bffe17 	ldw	r2,-8(fp)
     698:	10803224 	muli	r2,r2,200
     69c:	e0bffd15 	stw	r2,-12(fp)
		//We can never actually get to 20000 based on my CE2800 notes
		if(duty == MAX_OCR_VALUE)
     6a0:	e0bffd17 	ldw	r2,-12(fp)
     6a4:	10938818 	cmpnei	r2,r2,20000
     6a8:	1000031e 	bne	r2,zero,6b8 <PWMwriteOCRB+0x4c>
			duty--;
     6ac:	e0bffd17 	ldw	r2,-12(fp)
     6b0:	10bfffc4 	addi	r2,r2,-1
     6b4:	e0bffd15 	stw	r2,-12(fp)
		//set register
		*OCRB = duty;
     6b8:	00a02034 	movhi	r2,32896
     6bc:	10880a84 	addi	r2,r2,8234
     6c0:	e0fffd17 	ldw	r3,-12(fp)
     6c4:	10c0000d 	sth	r3,0(r2)
	} else {
		return -1; // return an error
	}
	// no error
	return 0;
     6c8:	e03fff15 	stw	zero,-4(fp)
     6cc:	00000206 	br	6d8 <PWMwriteOCRB+0x6c>
		if(duty == MAX_OCR_VALUE)
			duty--;
		//set register
		*OCRB = duty;
	} else {
		return -1; // return an error
     6d0:	00bfffc4 	movi	r2,-1
     6d4:	e0bfff15 	stw	r2,-4(fp)
     6d8:	e0bfff17 	ldw	r2,-4(fp)
	}
	// no error
	return 0;
}
     6dc:	e037883a 	mov	sp,fp
     6e0:	df000017 	ldw	fp,0(sp)
     6e4:	dec00104 	addi	sp,sp,4
     6e8:	f800283a 	ret

000006ec <timer_delay>:
/**
 * Delay for the time passed into the timer as a polling loop.
 * @param timeToDelay nanoseconds to delay
 * @param timer Pointer to TIMER hardware.
 */
void timer_delay(uint32_t timeToDelay, struct TIMER_HARDWARE volatile * timer){
     6ec:	defffb04 	addi	sp,sp,-20
     6f0:	dfc00415 	stw	ra,16(sp)
     6f4:	df000315 	stw	fp,12(sp)
     6f8:	df000304 	addi	fp,sp,12
     6fc:	e13ffe15 	stw	r4,-8(fp)
     700:	e17fff15 	stw	r5,-4(fp)

	//Convert from seconds to clock cycles
	timeToDelay = timeToDelay / TIME_PER_CYCLE;
     704:	e13ffe17 	ldw	r4,-8(fp)
     708:	01400504 	movi	r5,20
     70c:	0000e780 	call	e78 <__udivsi3>
     710:	e0bffe15 	stw	r2,-8(fp)

	//Set initial state of the timer needs both since they are 16 bit registers
	(timer -> PERIODL) = timeToDelay;
     714:	e0ffff17 	ldw	r3,-4(fp)
     718:	e0bffe17 	ldw	r2,-8(fp)
     71c:	18800215 	stw	r2,8(r3)
	(timer -> PERIODH) = timeToDelay >> 16;
     720:	e0bffe17 	ldw	r2,-8(fp)
     724:	1006d43a 	srli	r3,r2,16
     728:	e0bfff17 	ldw	r2,-4(fp)
     72c:	10c00315 	stw	r3,12(r2)

	// Clear t0 flag to reset timer if it was set before for whatever reason
	(timer -> STATUS) = TIMER_STATUS_T0_MASK;
     730:	e0ffff17 	ldw	r3,-4(fp)
     734:	00800044 	movi	r2,1
     738:	18800015 	stw	r2,0(r3)

	//Start timer count down by setting start bit
	uint8_t timerStatus = START_TIMER_MASK;
     73c:	00800104 	movi	r2,4
     740:	e0bffd05 	stb	r2,-12(fp)
	(timer -> CTRL) = timerStatus;
     744:	e0fffd03 	ldbu	r3,-12(fp)
     748:	e0bfff17 	ldw	r2,-4(fp)
     74c:	10c00115 	stw	r3,4(r2)

	//Loop while t0 flag is a zero
	while(((timer -> STATUS) & TIMER_STATUS_T0_MASK) == 0)
     750:	e0bfff17 	ldw	r2,-4(fp)
     754:	10800017 	ldw	r2,0(r2)
     758:	1080004c 	andi	r2,r2,1
     75c:	1005003a 	cmpeq	r2,r2,zero
     760:	103ffb1e 	bne	r2,zero,750 <timer_delay+0x64>
		;

	// Clear t0 flag to reset timer
	(timer -> STATUS) = TIMER_STATUS_T0_MASK;
     764:	e0ffff17 	ldw	r3,-4(fp)
     768:	00800044 	movi	r2,1
     76c:	18800015 	stw	r2,0(r3)
}
     770:	e037883a 	mov	sp,fp
     774:	dfc00117 	ldw	ra,4(sp)
     778:	df000017 	ldw	fp,0(sp)
     77c:	dec00204 	addi	sp,sp,8
     780:	f800283a 	ret

00000784 <timer_interrupt_init>:
 * @param isInterruptable 0 is disabling interrupts, 1 is enabling interrupts
 * @param timeToDelay Time to set in timer before interrupt once started.
 * @param timer Pointer to Timer hardware
 */
void timer_interrupt_init(uint8_t isInterruptable, uint32_t timeToDelay,
		struct TIMER_HARDWARE volatile * timer){
     784:	defffb04 	addi	sp,sp,-20
     788:	dfc00415 	stw	ra,16(sp)
     78c:	df000315 	stw	fp,12(sp)
     790:	df000304 	addi	fp,sp,12
     794:	e17ffe15 	stw	r5,-8(fp)
     798:	e1bfff15 	stw	r6,-4(fp)
     79c:	e13ffd05 	stb	r4,-12(fp)

	//check to see if enabling or disabling interrupts
	if(isInterruptable){
     7a0:	e0bffd03 	ldbu	r2,-12(fp)
     7a4:	1005003a 	cmpeq	r2,r2,zero
     7a8:	1000251e 	bne	r2,zero,840 <timer_interrupt_init+0xbc>

		// set IRQ0
		if(timer == TIMER_0){
     7ac:	e0ffff17 	ldw	r3,-4(fp)
     7b0:	00a02034 	movhi	r2,32896
     7b4:	10881004 	addi	r2,r2,8256
     7b8:	1880051e 	bne	r3,r2,7d0 <timer_interrupt_init+0x4c>
			// set interrupt ienable
			asm volatile(
     7bc:	01c00044 	movi	r7,1
     7c0:	000d30fa 	rdctl	r6,ienable
     7c4:	398eb03a 	or	r7,r7,r6
     7c8:	380170fa 	wrctl	ienable,r7
     7cc:	00000806 	br	7f0 <timer_interrupt_init+0x6c>
							::
						);

		}
		// set IRQ2
		else if (timer == TIMER_1){
     7d0:	e0ffff17 	ldw	r3,-4(fp)
     7d4:	00a02034 	movhi	r2,32896
     7d8:	10881804 	addi	r2,r2,8288
     7dc:	1880041e 	bne	r3,r2,7f0 <timer_interrupt_init+0x6c>
			// set interrupt ienable
			asm volatile(
     7e0:	01c00104 	movi	r7,4
     7e4:	000d30fa 	rdctl	r6,ienable
     7e8:	398eb03a 	or	r7,r7,r6
     7ec:	380170fa 	wrctl	ienable,r7
						);
		}

		//Clear t0 flag to reset timer if it was
		// set before for whatever reason
		(timer -> STATUS) = TIMER_STATUS_T0_MASK;
     7f0:	e0ffff17 	ldw	r3,-4(fp)
     7f4:	00800044 	movi	r2,1
     7f8:	18800015 	stw	r2,0(r3)

		//Convert from seconds to clock cycles
		timeToDelay = timeToDelay / TIME_PER_CYCLE;
     7fc:	e13ffe17 	ldw	r4,-8(fp)
     800:	01400504 	movi	r5,20
     804:	0000e780 	call	e78 <__udivsi3>
     808:	e0bffe15 	stw	r2,-8(fp)

		//Set initial state of the timer needs both since
		// they are 16 bit registers
		(timer -> PERIODL) = timeToDelay;
     80c:	e0ffff17 	ldw	r3,-4(fp)
     810:	e0bffe17 	ldw	r2,-8(fp)
     814:	18800215 	stw	r2,8(r3)
		(timer -> PERIODH) = timeToDelay >> 16;
     818:	e0bffe17 	ldw	r2,-8(fp)
     81c:	1006d43a 	srli	r3,r2,16
     820:	e0bfff17 	ldw	r2,-4(fp)
     824:	10c00315 	stw	r3,12(r2)

		// set interrupt on control register
		(timer -> CTRL) = (timer -> CTRL) | (INTERRUPT_TIMER_MASK | CONT_TIMER_MASK);
     828:	e0bfff17 	ldw	r2,-4(fp)
     82c:	10800117 	ldw	r2,4(r2)
     830:	10c000d4 	ori	r3,r2,3
     834:	e0bfff17 	ldw	r2,-4(fp)
     838:	10c00115 	stw	r3,4(r2)
     83c:	00001506 	br	894 <timer_interrupt_init+0x110>

	} else {
		// set IRQ to off
		if(timer == TIMER_0){
     840:	e0ffff17 	ldw	r3,-4(fp)
     844:	00a02034 	movhi	r2,32896
     848:	10881004 	addi	r2,r2,8256
     84c:	1880051e 	bne	r3,r2,864 <timer_interrupt_init+0xe0>
			asm volatile(
     850:	01ffff84 	movi	r7,-2
     854:	000d30fa 	rdctl	r6,ienable
     858:	398e703a 	and	r7,r7,r6
     85c:	380170fa 	wrctl	ienable,r7
     860:	00000806 	br	884 <timer_interrupt_init+0x100>
							"rdctl	r6, ienable\n\t"	// combine previous
							"and	r7, r7, r6\n\t"     // ienable and irq0
							"wrctl	ienable, r7"
							::
						);
		}else if(timer == TIMER_1){
     864:	e0ffff17 	ldw	r3,-4(fp)
     868:	00a02034 	movhi	r2,32896
     86c:	10881804 	addi	r2,r2,8288
     870:	1880041e 	bne	r3,r2,884 <timer_interrupt_init+0x100>
			asm volatile(
     874:	01fffec4 	movi	r7,-5
     878:	000d30fa 	rdctl	r6,ienable
     87c:	398e703a 	and	r7,r7,r6
     880:	380170fa 	wrctl	ienable,r7
							::
						);
		}

		// disable interrupt
		(timer -> CTRL) = (timer -> CTRL) & !(INTERRUPT_TIMER_MASK | CONT_TIMER_MASK);
     884:	e0bfff17 	ldw	r2,-4(fp)
     888:	10800117 	ldw	r2,4(r2)
     88c:	e0bfff17 	ldw	r2,-4(fp)
     890:	10000115 	stw	zero,4(r2)
	}
}
     894:	e037883a 	mov	sp,fp
     898:	dfc00117 	ldw	ra,4(sp)
     89c:	df000017 	ldw	fp,0(sp)
     8a0:	dec00204 	addi	sp,sp,8
     8a4:	f800283a 	ret

000008a8 <timer_interrupt_start_stop>:
 * Sets the timer to be started or stopped for interrupt use.
 * @param isStart boolean value whether to start of stop timer
 * @param timer Pointer to Timer hardware
 */
void timer_interrupt_start_stop(uint8_t isStart,
		struct TIMER_HARDWARE volatile * timer){
     8a8:	defffd04 	addi	sp,sp,-12
     8ac:	df000215 	stw	fp,8(sp)
     8b0:	df000204 	addi	fp,sp,8
     8b4:	e17fff15 	stw	r5,-4(fp)
     8b8:	e13ffe05 	stb	r4,-8(fp)
	//Start the timer
	if(isStart){
     8bc:	e0bffe03 	ldbu	r2,-8(fp)
     8c0:	1005003a 	cmpeq	r2,r2,zero
     8c4:	1000061e 	bne	r2,zero,8e0 <timer_interrupt_start_stop+0x38>
		(timer -> CTRL) = (timer -> CTRL) | START_TIMER_MASK;
     8c8:	e0bfff17 	ldw	r2,-4(fp)
     8cc:	10800117 	ldw	r2,4(r2)
     8d0:	10c00114 	ori	r3,r2,4
     8d4:	e0bfff17 	ldw	r2,-4(fp)
     8d8:	10c00115 	stw	r3,4(r2)
     8dc:	00000406 	br	8f0 <timer_interrupt_start_stop+0x48>
	}
	//Stop the timer
	else {
		(timer -> CTRL) = (timer -> CTRL) & !START_TIMER_MASK;
     8e0:	e0bfff17 	ldw	r2,-4(fp)
     8e4:	10800117 	ldw	r2,4(r2)
     8e8:	e0bfff17 	ldw	r2,-4(fp)
     8ec:	10000115 	stw	zero,4(r2)
	}
}
     8f0:	e037883a 	mov	sp,fp
     8f4:	df000017 	ldw	fp,0(sp)
     8f8:	dec00104 	addi	sp,sp,4
     8fc:	f800283a 	ret

00000900 <timer_ISR_TIMER_0>:
/**
 * Handles the interrupt for the given timer in name. Note that this clears the
 * interrupt but does not perform a callback. Instead template this function or
 * call from actual ISR.
 */
void timer_ISR_TIMER_0(){
     900:	deffff04 	addi	sp,sp,-4
     904:	df000015 	stw	fp,0(sp)
     908:	d839883a 	mov	fp,sp
	//write T0 flag to clear interrupt
	(TIMER_0 -> STATUS) = TIMER_STATUS_T0_MASK;
     90c:	00e02034 	movhi	r3,32896
     910:	18c81004 	addi	r3,r3,8256
     914:	00800044 	movi	r2,1
     918:	18800015 	stw	r2,0(r3)
}
     91c:	e037883a 	mov	sp,fp
     920:	df000017 	ldw	fp,0(sp)
     924:	dec00104 	addi	sp,sp,4
     928:	f800283a 	ret

0000092c <timer_ISR_TIMER_1>:
/**
 * Handles the interrupt for the given timer in name. Note that this clears the
 * interrupt but does not perform a callback. Instead template this function or
 * call from actual ISR.
 */
void timer_ISR_TIMER_1(){
     92c:	deffff04 	addi	sp,sp,-4
     930:	df000015 	stw	fp,0(sp)
     934:	d839883a 	mov	fp,sp
	//write T0 flag to clear interrupt
	(TIMER_1 -> STATUS) = TIMER_STATUS_T0_MASK;
     938:	00e02034 	movhi	r3,32896
     93c:	18c81804 	addi	r3,r3,8288
     940:	00800044 	movi	r2,1
     944:	18800015 	stw	r2,0(r3)
}
     948:	e037883a 	mov	sp,fp
     94c:	df000017 	ldw	fp,0(sp)
     950:	dec00104 	addi	sp,sp,4
     954:	f800283a 	ret

00000958 <uart_init>:
 * Sets UART for no interrupts, sets baud rate to specified
 * @param baudRate the baud to transmit at
 * @param UART pointer to the hardware device to interface with
 * @return -1 if error, 0 otherwise
 */
int uart_init(uint16_t baudRate, struct UART_Hardware volatile * UART){
     958:	defffa04 	addi	sp,sp,-24
     95c:	df000515 	stw	fp,20(sp)
     960:	df000504 	addi	fp,sp,20
     964:	e17ffd15 	stw	r5,-12(fp)
     968:	e13ffc0d 	sth	r4,-16(fp)

	// select the baud input as hardware signals
	uint8_t baud;
	switch(baudRate){
     96c:	e0bffc0b 	ldhu	r2,-16(fp)
     970:	e0bfff15 	stw	r2,-4(fp)
     974:	e0ffff17 	ldw	r3,-4(fp)
     978:	18825820 	cmpeqi	r2,r3,2400
     97c:	1000291e 	bne	r2,zero,a24 <uart_init+0xcc>
     980:	e0ffff17 	ldw	r3,-4(fp)
     984:	18825848 	cmpgei	r2,r3,2401
     988:	10000a1e 	bne	r2,zero,9b4 <uart_init+0x5c>
     98c:	e0ffff17 	ldw	r3,-4(fp)
     990:	18809620 	cmpeqi	r2,r3,600
     994:	1000291e 	bne	r2,zero,a3c <uart_init+0xe4>
     998:	e0ffff17 	ldw	r3,-4(fp)
     99c:	18812c20 	cmpeqi	r2,r3,1200
     9a0:	1000231e 	bne	r2,zero,a30 <uart_init+0xd8>
     9a4:	e0ffff17 	ldw	r3,-4(fp)
     9a8:	18804b20 	cmpeqi	r2,r3,300
     9ac:	1000261e 	bne	r2,zero,a48 <uart_init+0xf0>
     9b0:	00002806 	br	a54 <uart_init+0xfc>
     9b4:	e0ffff17 	ldw	r3,-4(fp)
     9b8:	18896020 	cmpeqi	r2,r3,9600
     9bc:	1000131e 	bne	r2,zero,a0c <uart_init+0xb4>
     9c0:	e0ffff17 	ldw	r3,-4(fp)
     9c4:	18896048 	cmpgei	r2,r3,9601
     9c8:	1000041e 	bne	r2,zero,9dc <uart_init+0x84>
     9cc:	e0ffff17 	ldw	r3,-4(fp)
     9d0:	1884b020 	cmpeqi	r2,r3,4800
     9d4:	1000101e 	bne	r2,zero,a18 <uart_init+0xc0>
     9d8:	00001e06 	br	a54 <uart_init+0xfc>
     9dc:	e0ffff17 	ldw	r3,-4(fp)
     9e0:	1892c020 	cmpeqi	r2,r3,19200
     9e4:	1000061e 	bne	r2,zero,a00 <uart_init+0xa8>
     9e8:	00a58014 	movui	r2,38400
     9ec:	e0ffff17 	ldw	r3,-4(fp)
     9f0:	18800126 	beq	r3,r2,9f8 <uart_init+0xa0>
     9f4:	00001706 	br	a54 <uart_init+0xfc>
		case 38400:
						baud = 0x0;
     9f8:	e03ffb05 	stb	zero,-20(fp)
						break;
     9fc:	00001806 	br	a60 <uart_init+0x108>
		case 19200:
						baud = 0x1;
     a00:	00800044 	movi	r2,1
     a04:	e0bffb05 	stb	r2,-20(fp)
						break;
     a08:	00001506 	br	a60 <uart_init+0x108>
		case 9600:
						baud = 0x2;
     a0c:	00800084 	movi	r2,2
     a10:	e0bffb05 	stb	r2,-20(fp)
						break;
     a14:	00001206 	br	a60 <uart_init+0x108>
		case 4800:
						baud = 0x3;
     a18:	008000c4 	movi	r2,3
     a1c:	e0bffb05 	stb	r2,-20(fp)
						break;
     a20:	00000f06 	br	a60 <uart_init+0x108>
		case 2400:
						baud = 0x4;
     a24:	00800104 	movi	r2,4
     a28:	e0bffb05 	stb	r2,-20(fp)
						break;
     a2c:	00000c06 	br	a60 <uart_init+0x108>
		case 1200:
						baud = 0x5;
     a30:	00800144 	movi	r2,5
     a34:	e0bffb05 	stb	r2,-20(fp)
						break;
     a38:	00000906 	br	a60 <uart_init+0x108>
		case 600:
						baud = 0x6;
     a3c:	00800184 	movi	r2,6
     a40:	e0bffb05 	stb	r2,-20(fp)
						break;
     a44:	00000606 	br	a60 <uart_init+0x108>
		case 300:
						baud = 0x7;
     a48:	008001c4 	movi	r2,7
     a4c:	e0bffb05 	stb	r2,-20(fp)
						break;
     a50:	00000306 	br	a60 <uart_init+0x108>
		default:
						// there is an error since input is invalid
						return -1;
     a54:	00bfffc4 	movi	r2,-1
     a58:	e0bffe15 	stw	r2,-8(fp)
     a5c:	00000406 	br	a70 <uart_init+0x118>

	}

	// No interrupts, 38500 Baud
	(UART->UCONTROL) = baud;
     a60:	e0fffd17 	ldw	r3,-12(fp)
     a64:	e0bffb03 	ldbu	r2,-20(fp)
     a68:	18800085 	stb	r2,2(r3)

	return 0;
     a6c:	e03ffe15 	stw	zero,-8(fp)
     a70:	e0bffe17 	ldw	r2,-8(fp)
}
     a74:	e037883a 	mov	sp,fp
     a78:	df000017 	ldw	fp,0(sp)
     a7c:	dec00104 	addi	sp,sp,4
     a80:	f800283a 	ret

00000a84 <uart_putch>:
 * stuck in a loop, for polling, until the transmit register is ready for next
 * byte.
 * @param x character to send out.
 * @param UART Hardware register pointer
 */
void uart_putch(char x, struct UART_Hardware volatile * UART){
     a84:	defffd04 	addi	sp,sp,-12
     a88:	df000215 	stw	fp,8(sp)
     a8c:	df000204 	addi	fp,sp,8
     a90:	e17fff15 	stw	r5,-4(fp)
     a94:	e13ffe05 	stb	r4,-8(fp)

	// Poll till char is received
	while(((UART -> USTATUS) & TDRE) == 0);
     a98:	e0bfff17 	ldw	r2,-4(fp)
     a9c:	10800043 	ldbu	r2,1(r2)
     aa0:	10803fcc 	andi	r2,r2,255
     aa4:	1080201c 	xori	r2,r2,128
     aa8:	10bfe004 	addi	r2,r2,-128
     aac:	1004403a 	cmpge	r2,r2,zero
     ab0:	103ff91e 	bne	r2,zero,a98 <uart_putch+0x14>

	// Write the character
	(UART -> UDR) = x;
     ab4:	e0ffff17 	ldw	r3,-4(fp)
     ab8:	e0bffe03 	ldbu	r2,-8(fp)
     abc:	18800005 	stb	r2,0(r3)
}
     ac0:	e037883a 	mov	sp,fp
     ac4:	df000017 	ldw	fp,0(sp)
     ac8:	dec00104 	addi	sp,sp,4
     acc:	f800283a 	ret

00000ad0 <uart_getch>:
 * Gets a character that was received from the UART. Caution: WIll be stuck in
 * a loop, due to polling, until a character is received.
 * @param UART Hardware register pointer
 * @return character received by the UART in ASCII encoding.
 */
char uart_getch(struct UART_Hardware volatile * UART){
     ad0:	defffd04 	addi	sp,sp,-12
     ad4:	df000215 	stw	fp,8(sp)
     ad8:	df000204 	addi	fp,sp,8
     adc:	e13fff15 	stw	r4,-4(fp)

	// Temporary memory
	char x;

	//Wait till transmitter ready
	while(((UART -> USTATUS) & RDRF) == 0);
     ae0:	e0bfff17 	ldw	r2,-4(fp)
     ae4:	10800043 	ldbu	r2,1(r2)
     ae8:	10803fcc 	andi	r2,r2,255
     aec:	1080100c 	andi	r2,r2,64
     af0:	1005003a 	cmpeq	r2,r2,zero
     af4:	103ffa1e 	bne	r2,zero,ae0 <uart_getch+0x10>

	// Read the character
	x = (UART -> UDR);
     af8:	e0bfff17 	ldw	r2,-4(fp)
     afc:	10800003 	ldbu	r2,0(r2)
     b00:	e0bffe05 	stb	r2,-8(fp)
	return x;
     b04:	e0bffe07 	ldb	r2,-8(fp)
}
     b08:	e037883a 	mov	sp,fp
     b0c:	df000017 	ldw	fp,0(sp)
     b10:	dec00104 	addi	sp,sp,4
     b14:	f800283a 	ret

00000b18 <testTimerInterrupt>:
extern void default_isr();

/**
 * Timer interrupt handler.
 */
void testTimerInterrupt(){
     b18:	defffe04 	addi	sp,sp,-8
     b1c:	dfc00115 	stw	ra,4(sp)
     b20:	df000015 	stw	fp,0(sp)
     b24:	d839883a 	mov	fp,sp
	LED_write(0xAAAA);
     b28:	012aaa94 	movui	r4,43690
     b2c:	00005540 	call	554 <LED_write>
	timer_ISR_TIMER_1();
     b30:	000092c0 	call	92c <timer_ISR_TIMER_1>
}
     b34:	e037883a 	mov	sp,fp
     b38:	dfc00117 	ldw	ra,4(sp)
     b3c:	df000017 	ldw	fp,0(sp)
     b40:	dec00204 	addi	sp,sp,8
     b44:	f800283a 	ret

00000b48 <alt_main>:
 * Main uses the alt_main form since interrupts are being used. Driver program
 * for all of the modules used in embedded 2 that are compatible with the
 * current NIOS image for embedded 3.
 * @return does not, Caught in the infinite loop.
 */
int alt_main(){
     b48:	defffc04 	addi	sp,sp,-16
     b4c:	dfc00315 	stw	ra,12(sp)
     b50:	df000215 	stw	fp,8(sp)
     b54:	df000204 	addi	fp,sp,8

	// LED test
	LED_write(0xFFFF);
     b58:	013fffd4 	movui	r4,65535
     b5c:	00005540 	call	554 <LED_write>

	// TIMER test
	timer_delay(SECOND_CONSTANT * 2,TIMER_0);
     b60:	011dcdb4 	movhi	r4,30518
     b64:	21250004 	addi	r4,r4,-27648
     b68:	01602034 	movhi	r5,32896
     b6c:	29481004 	addi	r5,r5,8256
     b70:	00006ec0 	call	6ec <timer_delay>
	LED_write(0x0000);
     b74:	0009883a 	mov	r4,zero
     b78:	00005540 	call	554 <LED_write>
	timer_delay(SECOND_CONSTANT,TIMER_1);
     b7c:	010ee6f4 	movhi	r4,15259
     b80:	21328004 	addi	r4,r4,-13824
     b84:	01602034 	movhi	r5,32896
     b88:	29481804 	addi	r5,r5,8288
     b8c:	00006ec0 	call	6ec <timer_delay>
	LED_write(0x5555);
     b90:	01155544 	movi	r4,21845
     b94:	00005540 	call	554 <LED_write>

	//start interrupts
	timer_interrupt_init(1,SECOND_CONSTANT,TIMER_1);
     b98:	01000044 	movi	r4,1
     b9c:	014ee6f4 	movhi	r5,15259
     ba0:	29728004 	addi	r5,r5,-13824
     ba4:	01a02034 	movhi	r6,32896
     ba8:	31881804 	addi	r6,r6,8288
     bac:	00007840 	call	784 <timer_interrupt_init>
	timer_interrupt_start_stop(1,TIMER_1);
     bb0:	01000044 	movi	r4,1
     bb4:	01602034 	movhi	r5,32896
     bb8:	29481804 	addi	r5,r5,8288
     bbc:	00008a80 	call	8a8 <timer_interrupt_start_stop>
	asm volatile(
     bc0:	01c00034 	movhi	r7,0
     bc4:	39c05704 	addi	r7,r7,348
     bc8:	01800034 	movhi	r6,0
     bcc:	31834604 	addi	r6,r6,3352
     bd0:	31c00015 	stw	r7,0(r6)
     bd4:	01c00034 	movhi	r7,0
     bd8:	39c2c604 	addi	r7,r7,2840
     bdc:	01800034 	movhi	r6,0
     be0:	31834804 	addi	r6,r6,3360
     be4:	31c00015 	stw	r7,0(r6)
     be8:	01c00044 	movi	r7,1
     bec:	3801703a 	wrctl	status,r7
					"movi	r7, (1 << PIE)\n\t"
					"wrctl	status, r7\n\t"
					::
				);

	timer_delay(SECOND_CONSTANT*2,TIMER_0);
     bf0:	011dcdb4 	movhi	r4,30518
     bf4:	21250004 	addi	r4,r4,-27648
     bf8:	01602034 	movhi	r5,32896
     bfc:	29481004 	addi	r5,r5,8256
     c00:	00006ec0 	call	6ec <timer_delay>

	//disable interrupts
	asm volatile(
     c04:	0001703a 	wrctl	status,zero
     c08:	01c00034 	movhi	r7,0
     c0c:	39c05704 	addi	r7,r7,348
     c10:	01800034 	movhi	r6,0
     c14:	31834604 	addi	r6,r6,3352
     c18:	31c00015 	stw	r7,0(r6)
     c1c:	01c00034 	movhi	r7,0
     c20:	39c05704 	addi	r7,r7,348
     c24:	01800034 	movhi	r6,0
     c28:	31834804 	addi	r6,r6,3360
     c2c:	31c00015 	stw	r7,0(r6)
					"movia r7, default_isr\n\t"
					"movia r6, IRQ_2\n\t"
					"stw r7, 0(r6)\n\t"
					::
				);
	timer_interrupt_start_stop(0, TIMER_1);
     c30:	0009883a 	mov	r4,zero
     c34:	01602034 	movhi	r5,32896
     c38:	29481804 	addi	r5,r5,8288
     c3c:	00008a80 	call	8a8 <timer_interrupt_start_stop>

	LED_write(0x0000);
     c40:	0009883a 	mov	r4,zero
     c44:	00005540 	call	554 <LED_write>

	// PUSHBUTTON test
	while(pushbutton_read(PUSHBUTTON_1_MASK | PUSHBUTTON_2_MASK)){
     c48:	010000c4 	movi	r4,3
     c4c:	00005b00 	call	5b0 <pushbutton_read>
     c50:	10803fcc 	andi	r2,r2,255
     c54:	1004c03a 	cmpne	r2,r2,zero
     c58:	103ffb1e 	bne	r2,zero,c48 <alt_main+0x100>
		//do nothing until condition met
	}
	LED_write(0x01);
     c5c:	01000044 	movi	r4,1
     c60:	00005540 	call	554 <LED_write>

	// UART test
	uart_init(9600,UART_0);
     c64:	01096004 	movi	r4,9600
     c68:	01602034 	movhi	r5,32896
     c6c:	29483004 	addi	r5,r5,8384
     c70:	00009580 	call	958 <uart_init>

	char* str = "Hello World!\n";
     c74:	00800034 	movhi	r2,0
     c78:	10841e04 	addi	r2,r2,4216
     c7c:	e0bfff15 	stw	r2,-4(fp)
	while(*str != '\0'){
     c80:	00000b06 	br	cb0 <alt_main+0x168>
		uart_putch(*str,UART_0);
     c84:	e0bfff17 	ldw	r2,-4(fp)
     c88:	10800003 	ldbu	r2,0(r2)
     c8c:	11003fcc 	andi	r4,r2,255
     c90:	2100201c 	xori	r4,r4,128
     c94:	213fe004 	addi	r4,r4,-128
     c98:	01602034 	movhi	r5,32896
     c9c:	29483004 	addi	r5,r5,8384
     ca0:	0000a840 	call	a84 <uart_putch>
		str++;
     ca4:	e0bfff17 	ldw	r2,-4(fp)
     ca8:	10800044 	addi	r2,r2,1
     cac:	e0bfff15 	stw	r2,-4(fp)

	// UART test
	uart_init(9600,UART_0);

	char* str = "Hello World!\n";
	while(*str != '\0'){
     cb0:	e0bfff17 	ldw	r2,-4(fp)
     cb4:	10800003 	ldbu	r2,0(r2)
     cb8:	10803fcc 	andi	r2,r2,255
     cbc:	1080201c 	xori	r2,r2,128
     cc0:	10bfe004 	addi	r2,r2,-128
     cc4:	1004c03a 	cmpne	r2,r2,zero
     cc8:	103fee1e 	bne	r2,zero,c84 <alt_main+0x13c>
		uart_putch(*str,UART_0);
		str++;
	}
	char c = uart_getch(UART_0);
     ccc:	01202034 	movhi	r4,32896
     cd0:	21083004 	addi	r4,r4,8384
     cd4:	0000ad00 	call	ad0 <uart_getch>
     cd8:	e0bffe05 	stb	r2,-8(fp)
	uart_putch(c,UART_0);
     cdc:	e13ffe07 	ldb	r4,-8(fp)
     ce0:	01602034 	movhi	r5,32896
     ce4:	29483004 	addi	r5,r5,8384
     ce8:	0000a840 	call	a84 <uart_putch>

	// PWM test
	PWMwriteOCRA(50);
     cec:	01000c84 	movi	r4,50
     cf0:	00005ec0 	call	5ec <PWMwriteOCRA>
	PWMwriteOCRB(25);
     cf4:	01000644 	movi	r4,25
     cf8:	000066c0 	call	66c <PWMwriteOCRB>

	// LCD test
	lcd_portInit(0xff);
     cfc:	01003fc4 	movi	r4,255
     d00:	00003b40 	call	3b4 <lcd_portInit>
	lcd_init();
     d04:	00003680 	call	368 <lcd_init>
	lcd_printString("Hello World!\nAwesome.");
     d08:	01000034 	movhi	r4,0
     d0c:	21042204 	addi	r4,r4,4232
     d10:	00003e40 	call	3e4 <lcd_printString>

	while(1){
		/* Trap */
	}
     d14:	003fff06 	br	d14 <alt_main+0x1cc>

00000d18 <IRQ_0>:
     d18:	0000015c 	xori	zero,zero,5

00000d1c <IRQ_1>:
     d1c:	0000015c 	xori	zero,zero,5

00000d20 <IRQ_2>:
     d20:	0000015c 	xori	zero,zero,5

00000d24 <IRQ_3>:
     d24:	0000015c 	xori	zero,zero,5

00000d28 <IRQ_4>:
     d28:	0000015c 	xori	zero,zero,5

00000d2c <IRQ_5>:
     d2c:	0000015c 	xori	zero,zero,5

00000d30 <IRQ_6>:
     d30:	0000015c 	xori	zero,zero,5

00000d34 <IRQ_7>:
     d34:	0000015c 	xori	zero,zero,5

00000d38 <IRQ_8>:
     d38:	0000015c 	xori	zero,zero,5

00000d3c <udivmodsi4>:
     d3c:	29001b2e 	bgeu	r5,r4,dac <udivmodsi4+0x70>
     d40:	28001a16 	blt	r5,zero,dac <udivmodsi4+0x70>
     d44:	00800044 	movi	r2,1
     d48:	0007883a 	mov	r3,zero
     d4c:	01c007c4 	movi	r7,31
     d50:	00000306 	br	d60 <udivmodsi4+0x24>
     d54:	19c01326 	beq	r3,r7,da4 <udivmodsi4+0x68>
     d58:	18c00044 	addi	r3,r3,1
     d5c:	28000416 	blt	r5,zero,d70 <udivmodsi4+0x34>
     d60:	294b883a 	add	r5,r5,r5
     d64:	1085883a 	add	r2,r2,r2
     d68:	293ffa36 	bltu	r5,r4,d54 <udivmodsi4+0x18>
     d6c:	10000d26 	beq	r2,zero,da4 <udivmodsi4+0x68>
     d70:	0007883a 	mov	r3,zero
     d74:	21400236 	bltu	r4,r5,d80 <udivmodsi4+0x44>
     d78:	2149c83a 	sub	r4,r4,r5
     d7c:	1886b03a 	or	r3,r3,r2
     d80:	1004d07a 	srli	r2,r2,1
     d84:	280ad07a 	srli	r5,r5,1
     d88:	103ffa1e 	bne	r2,zero,d74 <udivmodsi4+0x38>
     d8c:	30000226 	beq	r6,zero,d98 <udivmodsi4+0x5c>
     d90:	2005883a 	mov	r2,r4
     d94:	f800283a 	ret
     d98:	1809883a 	mov	r4,r3
     d9c:	2005883a 	mov	r2,r4
     da0:	f800283a 	ret
     da4:	0007883a 	mov	r3,zero
     da8:	003ff806 	br	d8c <udivmodsi4+0x50>
     dac:	00800044 	movi	r2,1
     db0:	0007883a 	mov	r3,zero
     db4:	003fef06 	br	d74 <udivmodsi4+0x38>

00000db8 <__divsi3>:
     db8:	defffe04 	addi	sp,sp,-8
     dbc:	dc000015 	stw	r16,0(sp)
     dc0:	dfc00115 	stw	ra,4(sp)
     dc4:	0021883a 	mov	r16,zero
     dc8:	20000c16 	blt	r4,zero,dfc <__divsi3+0x44>
     dcc:	000d883a 	mov	r6,zero
     dd0:	28000e16 	blt	r5,zero,e0c <__divsi3+0x54>
     dd4:	0000d3c0 	call	d3c <udivmodsi4>
     dd8:	1007883a 	mov	r3,r2
     ddc:	8005003a 	cmpeq	r2,r16,zero
     de0:	1000011e 	bne	r2,zero,de8 <__divsi3+0x30>
     de4:	00c7c83a 	sub	r3,zero,r3
     de8:	1805883a 	mov	r2,r3
     dec:	dfc00117 	ldw	ra,4(sp)
     df0:	dc000017 	ldw	r16,0(sp)
     df4:	dec00204 	addi	sp,sp,8
     df8:	f800283a 	ret
     dfc:	0109c83a 	sub	r4,zero,r4
     e00:	04000044 	movi	r16,1
     e04:	000d883a 	mov	r6,zero
     e08:	283ff20e 	bge	r5,zero,dd4 <__divsi3+0x1c>
     e0c:	014bc83a 	sub	r5,zero,r5
     e10:	8021003a 	cmpeq	r16,r16,zero
     e14:	003fef06 	br	dd4 <__divsi3+0x1c>

00000e18 <__modsi3>:
     e18:	deffff04 	addi	sp,sp,-4
     e1c:	dfc00015 	stw	ra,0(sp)
     e20:	01800044 	movi	r6,1
     e24:	2807883a 	mov	r3,r5
     e28:	20000416 	blt	r4,zero,e3c <__modsi3+0x24>
     e2c:	28000c16 	blt	r5,zero,e60 <__modsi3+0x48>
     e30:	dfc00017 	ldw	ra,0(sp)
     e34:	dec00104 	addi	sp,sp,4
     e38:	0000d3c1 	jmpi	d3c <udivmodsi4>
     e3c:	0109c83a 	sub	r4,zero,r4
     e40:	28000b16 	blt	r5,zero,e70 <__modsi3+0x58>
     e44:	180b883a 	mov	r5,r3
     e48:	01800044 	movi	r6,1
     e4c:	0000d3c0 	call	d3c <udivmodsi4>
     e50:	0085c83a 	sub	r2,zero,r2
     e54:	dfc00017 	ldw	ra,0(sp)
     e58:	dec00104 	addi	sp,sp,4
     e5c:	f800283a 	ret
     e60:	014bc83a 	sub	r5,zero,r5
     e64:	dfc00017 	ldw	ra,0(sp)
     e68:	dec00104 	addi	sp,sp,4
     e6c:	0000d3c1 	jmpi	d3c <udivmodsi4>
     e70:	0147c83a 	sub	r3,zero,r5
     e74:	003ff306 	br	e44 <__modsi3+0x2c>

00000e78 <__udivsi3>:
     e78:	000d883a 	mov	r6,zero
     e7c:	0000d3c1 	jmpi	d3c <udivmodsi4>

00000e80 <__umodsi3>:
     e80:	01800044 	movi	r6,1
     e84:	0000d3c1 	jmpi	d3c <udivmodsi4>

00000e88 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
     e88:	defffe04 	addi	sp,sp,-8
     e8c:	dfc00115 	stw	ra,4(sp)
     e90:	df000015 	stw	fp,0(sp)
     e94:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
     e98:	01000034 	movhi	r4,0
     e9c:	21042804 	addi	r4,r4,4256
     ea0:	01400034 	movhi	r5,0
     ea4:	29442804 	addi	r5,r5,4256
     ea8:	01800034 	movhi	r6,0
     eac:	31842804 	addi	r6,r6,4256
     eb0:	0000f080 	call	f08 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
     eb4:	01000034 	movhi	r4,0
     eb8:	21000804 	addi	r4,r4,32
     ebc:	01400034 	movhi	r5,0
     ec0:	29400804 	addi	r5,r5,32
     ec4:	01800034 	movhi	r6,0
     ec8:	31805c04 	addi	r6,r6,368
     ecc:	0000f080 	call	f08 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
     ed0:	01000034 	movhi	r4,0
     ed4:	21041e04 	addi	r4,r4,4216
     ed8:	01400034 	movhi	r5,0
     edc:	29441e04 	addi	r5,r5,4216
     ee0:	01800034 	movhi	r6,0
     ee4:	31842804 	addi	r6,r6,4256
     ee8:	0000f080 	call	f08 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
     eec:	0000f740 	call	f74 <alt_dcache_flush_all>
  alt_icache_flush_all();
     ef0:	0000fb80 	call	fb8 <alt_icache_flush_all>
}
     ef4:	e037883a 	mov	sp,fp
     ef8:	dfc00117 	ldw	ra,4(sp)
     efc:	df000017 	ldw	fp,0(sp)
     f00:	dec00204 	addi	sp,sp,8
     f04:	f800283a 	ret

00000f08 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
     f08:	defffc04 	addi	sp,sp,-16
     f0c:	df000315 	stw	fp,12(sp)
     f10:	df000304 	addi	fp,sp,12
     f14:	e13ffd15 	stw	r4,-12(fp)
     f18:	e17ffe15 	stw	r5,-8(fp)
     f1c:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
     f20:	e0fffe17 	ldw	r3,-8(fp)
     f24:	e0bffd17 	ldw	r2,-12(fp)
     f28:	18800e26 	beq	r3,r2,f64 <alt_load_section+0x5c>
  {
    while( to != end )
     f2c:	00000a06 	br	f58 <alt_load_section+0x50>
    {
      *to++ = *from++;
     f30:	e0bffd17 	ldw	r2,-12(fp)
     f34:	10c00017 	ldw	r3,0(r2)
     f38:	e0bffe17 	ldw	r2,-8(fp)
     f3c:	10c00015 	stw	r3,0(r2)
     f40:	e0bffe17 	ldw	r2,-8(fp)
     f44:	10800104 	addi	r2,r2,4
     f48:	e0bffe15 	stw	r2,-8(fp)
     f4c:	e0bffd17 	ldw	r2,-12(fp)
     f50:	10800104 	addi	r2,r2,4
     f54:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
     f58:	e0fffe17 	ldw	r3,-8(fp)
     f5c:	e0bfff17 	ldw	r2,-4(fp)
     f60:	18bff31e 	bne	r3,r2,f30 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
     f64:	e037883a 	mov	sp,fp
     f68:	df000017 	ldw	fp,0(sp)
     f6c:	dec00104 	addi	sp,sp,4
     f70:	f800283a 	ret

00000f74 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
     f74:	defffe04 	addi	sp,sp,-8
     f78:	df000115 	stw	fp,4(sp)
     f7c:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
     f80:	e03fff15 	stw	zero,-4(fp)
     f84:	00000506 	br	f9c <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
     f88:	e0bfff17 	ldw	r2,-4(fp)
     f8c:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
     f90:	e0bfff17 	ldw	r2,-4(fp)
     f94:	10800804 	addi	r2,r2,32
     f98:	e0bfff15 	stw	r2,-4(fp)
     f9c:	e0bfff17 	ldw	r2,-4(fp)
     fa0:	10820030 	cmpltui	r2,r2,2048
     fa4:	103ff81e 	bne	r2,zero,f88 <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
     fa8:	e037883a 	mov	sp,fp
     fac:	df000017 	ldw	fp,0(sp)
     fb0:	dec00104 	addi	sp,sp,4
     fb4:	f800283a 	ret

00000fb8 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
     fb8:	defffe04 	addi	sp,sp,-8
     fbc:	dfc00115 	stw	ra,4(sp)
     fc0:	df000015 	stw	fp,0(sp)
     fc4:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
     fc8:	0009883a 	mov	r4,zero
     fcc:	01440004 	movi	r5,4096
     fd0:	0000fe80 	call	fe8 <alt_icache_flush>
#endif
}
     fd4:	e037883a 	mov	sp,fp
     fd8:	dfc00117 	ldw	ra,4(sp)
     fdc:	df000017 	ldw	fp,0(sp)
     fe0:	dec00204 	addi	sp,sp,8
     fe4:	f800283a 	ret

00000fe8 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
     fe8:	defffb04 	addi	sp,sp,-20
     fec:	df000415 	stw	fp,16(sp)
     ff0:	df000404 	addi	fp,sp,16
     ff4:	e13ffe15 	stw	r4,-8(fp)
     ff8:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
     ffc:	e0bfff17 	ldw	r2,-4(fp)
    1000:	10840070 	cmpltui	r2,r2,4097
    1004:	1000021e 	bne	r2,zero,1010 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
    1008:	00840004 	movi	r2,4096
    100c:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
    1010:	e0fffe17 	ldw	r3,-8(fp)
    1014:	e0bfff17 	ldw	r2,-4(fp)
    1018:	1885883a 	add	r2,r3,r2
    101c:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
    1020:	e0bffe17 	ldw	r2,-8(fp)
    1024:	e0bffd15 	stw	r2,-12(fp)
    1028:	00000506 	br	1040 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
    102c:	e0bffd17 	ldw	r2,-12(fp)
    1030:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
    1034:	e0bffd17 	ldw	r2,-12(fp)
    1038:	10800804 	addi	r2,r2,32
    103c:	e0bffd15 	stw	r2,-12(fp)
    1040:	e0fffd17 	ldw	r3,-12(fp)
    1044:	e0bffc17 	ldw	r2,-16(fp)
    1048:	18bff836 	bltu	r3,r2,102c <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
    104c:	e0bffe17 	ldw	r2,-8(fp)
    1050:	108007cc 	andi	r2,r2,31
    1054:	1005003a 	cmpeq	r2,r2,zero
    1058:	1000021e 	bne	r2,zero,1064 <alt_icache_flush+0x7c>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
    105c:	e0bffd17 	ldw	r2,-12(fp)
    1060:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
    1064:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
    1068:	e037883a 	mov	sp,fp
    106c:	df000017 	ldw	fp,0(sp)
    1070:	dec00104 	addi	sp,sp,4
    1074:	f800283a 	ret
